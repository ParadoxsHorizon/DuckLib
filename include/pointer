#ifndef ___DUCKED_C_POINTER_EXTENSIONS_HPP___
#define ___DUCKED_C_POINTER_EXTENSIONS_HPP___

#include "type_traits"
#include "observable_unique_ptr.hpp"
#include <memory>

namespace std {

	using namespace oup; // Import observable unique pointers

	
	// -- Smart Pointer Traits From: https://github.com/agruzdev/Yato --


	namespace details {
		template<typename _T, template <typename...> class _PtrType, typename _Enable = void>
		struct is_smart_ptr_impl : std::false_type { };

		template<typename _T, template <typename...> class _PtrType, typename... _Args>
		struct is_smart_ptr_impl<_PtrType<_T, _Args...>, _PtrType, void> : std::true_type { };
	}

	/**
	 * Detect shared_ptr
	 * is_shared_ptr<T>::value is true when T is shared_ptr<V> for some V
	 */
	template<typename _T>
	using is_shared_ptr = details::is_smart_ptr_impl<_T, std::shared_ptr>;

	/**
	 * Detect unique_ptr
	 * is_unique_ptr<T>::value is true when T is unique_ptr<V> for some V
	 */
	template<typename _T>
	using is_unique_ptr = details::is_smart_ptr_impl<_T, std::unique_ptr>;

	/**
	 * Detect weak_ptr
	 * is_weak_ptr<T>::value is true when T is weak_ptr<V> for some V
	 */
	template<typename _T>
	using is_weak_ptr = details::is_smart_ptr_impl<_T, std::weak_ptr>;

	template<typename _T>
	using is_observable_unique_ptr = details::is_smart_ptr_impl<_T, observable_unique_ptr>;

	template<typename _T>
	using is_observable_sealed_ptr = details::is_smart_ptr_impl<_T, observable_sealed_ptr>;

	template<typename _T>
	using is_observer_ptr = details::is_smart_ptr_impl<_T, observer_ptr>;

	/**
	 * Detect shared_ptr or unique_ptr
	 * auto_ptr is evil - don't use it
	 * weak_ptr has a little bit different behavior... so I dont want to mix it with others
	 */
	template<typename T>
	struct is_smart_ptr {
		static constexpr bool value = is_shared_ptr<T>::value || is_unique_ptr<T>::value || is_observable_unique_ptr<T>::value || is_observable_sealed_ptr<T>::value;
	};


	// Relative pointer, stores the pointer as an offset on the this pointer (allows storing pointers close to eachother in much less space)
	// NOTE: You should declair variables of this type as volatile so that their "this" pointer won't be optimized away
	template<typename T, typename SizeType = int>
	requires std::is_integral_v<SizeType>
	class relative_ptr {
		SizeType offset;
	public:
		constexpr relative_ptr(const SizeType offset) : offset(offset) {}
		constexpr relative_ptr(const T* other) : offset(other - (T*)this) {}
		template<typename T2> constexpr relative_ptr(const relative_ptr<T2, SizeType> other) : offset(other.data() - (T2*)this) {}

		constexpr inline relative_ptr& operator=(const SizeType offset) { this->offset = offset; return *this; }
		constexpr inline relative_ptr& operator=(const T* other) { offset = other - (T*)this; return *this; }
		template<typename T2, typename Size2> constexpr inline relative_ptr& operator=(const relative_ptr<T2, Size2> other) { offset = other.data() - (T2*)this; return *this; }

		constexpr inline T* data() { return (T*) (((char*) this) + offset); }
		constexpr inline const T* data() const { return (T*) (((char*) this) + offset); }

		constexpr inline T& operator*() { return *data(); }
		constexpr inline const T& operator*() const { return *data(); }
		constexpr inline T* operator->() { return data(); }
		constexpr inline const T* operator->() const { return data(); }

		template<typename T2, typename Size2> constexpr inline auto operator<=>(const relative_ptr<T2, Size2> other) const { return (void*) data() <=>  (void*) other.data(); }

		constexpr inline relative_ptr& operator++(int) { offset++; return *this; }
		constexpr inline relative_ptr operator++() { auto out = *this; offset++; return out; }
		constexpr inline relative_ptr& operator+=(SizeType o) { offset += o; return *this; }
		constexpr inline relative_ptr operator+(SizeType o) const { auto out = *this; out += o; return out; }
		constexpr inline relative_ptr& operator--(int) { offset--; return *this; }
		constexpr inline relative_ptr operator--() { auto out = *this; offset--; return out; }
		constexpr inline relative_ptr& operator-=(SizeType o) { offset -= o; return *this; }
		constexpr inline relative_ptr operator-(SizeType o) const { auto out = *this; out -= o; return out; }

		constexpr inline int64_t operator-(const void* o) const { return data() - o; }
		template<typename T2, typename Size2> constexpr inline int64_t operator-(const relative_ptr<T2, Size2> o) { return data() - o.data(); }
	};
	template<typename T, typename SizeType> struct is_pointer<relative_ptr<T, SizeType>> : true_type {};


	// Based pointer, stores the pointer as an offset relative to another pointer
	template<typename T, typename SizeType = int>
	requires std::is_integral_v<SizeType>
	class based_ptr {
		volatile char* base;
		SizeType offset;
	public:
		constexpr based_ptr(const void* base = nullptr, const SizeType offset = 0) : base((char*) base), offset(offset) {}
		constexpr based_ptr(const void* base, const T* target) : base((char*) base), offset(target - (T*)base) {}
		template<typename T2> constexpr based_ptr(const based_ptr<T2, SizeType>& other) : base(other.base), offset(other.offset) {}
		template<typename T2> constexpr based_ptr(const based_ptr<T2, SizeType>&& other) : base(other.base), offset(other.offset) {}

		constexpr inline void set_base(const void* base) {
			offset += this->base - (char*) base;
			this->base = (char*) base;
		}

		constexpr inline based_ptr& operator=(const SizeType offset) { this->offset = offset; return *this; }
		constexpr inline based_ptr& operator=(const T* other) { offset = other - (T*)base; return *this; }
		template<typename T2, typename Size2> constexpr inline based_ptr& operator=(const based_ptr<T2, Size2>& other) { base = other.base; offset = other.offset; return *this; }
		template<typename T2, typename Size2> constexpr inline based_ptr& operator=(const based_ptr<T2, Size2>&& other) { base = other.base; offset = other.offset; return *this; }

		constexpr inline T* data() { return (T*) (base + offset); }
		constexpr inline const T* data() const { return (T*) (base + offset); }

		constexpr inline T& operator*() { return *data(); }
		constexpr inline const T& operator*() const { return *data(); }
		constexpr inline T* operator->() { return data(); }
		constexpr inline const T* operator->() const { return data(); }

		constexpr inline auto operator<=>(based_ptr& other) { return data() <=> other.data(); }
		constexpr inline auto operator<=>(based_ptr&& other) { return operator<=>(other); }

		constexpr inline based_ptr& operator++(int) { offset++; return *this; }
		constexpr inline based_ptr operator++() { auto out = *this; offset++; return out; }
		constexpr inline based_ptr& operator+=(SizeType o) { offset += o; return *this; }
		constexpr inline based_ptr operator+(SizeType o) const { auto out = *this; out += o; return out; }
		constexpr inline based_ptr& operator--(int) { offset--; return *this; }
		constexpr inline based_ptr operator--() { auto out = *this; offset--; return out; }
		constexpr inline based_ptr& operator-=(SizeType o) { offset -= o; return *this; }
		constexpr inline based_ptr operator-(SizeType o) const { auto out = *this; out -= o; return out; }

		constexpr inline int64_t operator-(const void* o) const { return data() - o; }
		template<typename T2, typename Size2> constexpr inline int64_t operator-(const based_ptr<T2, Size2>& o) { return data() - o.data(); }
		template<typename T2, typename Size2> constexpr inline int64_t operator-(const based_ptr<T2, Size2>&& o) { return data() - o.data(); }
	};
	template<typename T, typename SizeType> struct is_pointer<based_ptr<T, SizeType>> : true_type {};


	// -- Not Null Wrapper From: https://github.com/agruzdev/Yato --


	/**
	 * not_null wrapper forcing pointers to be not nullptr
	 */
	template<typename T, typename Enable = void>
	class not_null {};

	/**
	 * Implementation for raw pointers
	 */
	template<typename T>
	class not_null<T, typename std::enable_if< std::is_pointer<T>::value >::type > {
		using element_type = typename std::remove_reference<decltype(*(std::declval<T>()))>::type;
		T m_pointer;

	public:
		constexpr
		not_null(T ptr) : m_pointer(ptr) {
			if(ptr == nullptr) throw std::invalid_argument("The given pointer must not be null");
		}

		not_null(std::nullptr_t ptr) = delete;

		not_null(const not_null&) = default;
		not_null& operator=(const not_null&) = default;

		~not_null() = default;

		constexpr operator T () const noexcept { return m_pointer; }
		constexpr T get() const noexcept { return m_pointer; }
		constexpr T operator->() const noexcept { return m_pointer; }
		constexpr const element_type & operator*() const noexcept { return *m_pointer; }
		element_type & operator*() noexcept { return *m_pointer; }
	};
	/**
	 * Implementation for smart pointers
	 */
	template<typename T>
	class not_null<T, typename std::enable_if< is_smart_ptr<T>::value >::type > {
		using element_type = typename T::element_type;
		const T & m_smart_pointer;
	public:
		constexpr not_null(const T & ptr) : m_smart_pointer(ptr) {
			if(ptr == nullptr) throw std::invalid_argument("The given pointer must not be null");
		}

		not_null(std::nullptr_t ptr) = delete;

		not_null(const not_null&) = default;
		not_null& operator=(const not_null&) = default;

		~not_null() = default;

		operator T& () noexcept { return m_smart_pointer; }
		constexpr const element_type* get() const noexcept { return m_smart_pointer.get(); }
		element_type* get() noexcept { return m_smart_pointer.get(); }
		constexpr const element_type* operator->() const noexcept { return m_smart_pointer.operator->(); }
		element_type* operator->() noexcept { return m_smart_pointer.operator->(); }
		constexpr const element_type & operator*() const noexcept { return *m_smart_pointer; }
		element_type & operator*() noexcept { return *m_smart_pointer; }
	};

} // std

#endif // ___DUCKED_C_POINTER_EXTENSIONS_HPP___