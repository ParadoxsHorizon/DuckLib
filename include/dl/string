#ifndef ___DUCKED_C_STRING_HPP___
#define ___DUCKED_C_STRING_HPP___
#include <string>
#include <valarray>

#include "endian"
#include "dl/concepts"
#include "dl/type_traits"
#include "utf8.h"
#include "strnatcmp.h"

namespace std {
	static struct modify_original_t { explicit modify_original_t() = default; } modify_original;
	static struct utf8_t { explicit utf8_t() = default; } utf8;
}

namespace dl {
	struct slice: public std::slice {
		slice(ptrdiff_t start = 0, ptrdiff_t end = -1) : std::slice(reference_cast<size_t>(start), reference_cast<size_t>(end), 1) {}

		// Normalizes a slice to only have positive numbers (converts negative values to the equivalents in terms of a container's size)
		std::slice apply_size(size_t size) const {
			if(stride() != 1) throw std::invalid_argument("DuckLib types currently only support slices with a stride of 1!");

			auto _start = std::slice::start();
			auto start = reference_cast<ptrdiff_t>(_start);
			if(start < 0) start += size;

			auto _end = std::slice::size();
			auto end = reference_cast<ptrdiff_t>(_end);
			if(end < 0) end += size;
			return std::slice(start, end - start, 1);
		}

		static inline slice size(ptrdiff_t start, size_t length) { return slice(start, start + length); }
		static inline slice size(size_t length) { return slice(0, length); }
	};

	struct slice_inclusive: public slice {
		// using slice::slice;
		using slice::operator=;
		explicit slice_inclusive(ptrdiff_t begin = 0, ptrdiff_t end = -2) : slice(begin, end + 1) {}
	};


	namespace detail {
		extern "C" {
			#define IGNORE_UNNEEDED_CONVERSION_C
			#include "UtfConv.c"
			#undef IGNORE_UNNEEDED_CONVERSION_C
		}

		// Helper concept which checks if the base CharType is an 8bit char
		template<typename CharType>
		concept is_char_8 = requires(CharType a) {
			(std::is_same_v<CharType, uint8_t> || std::is_same_v<CharType, int8_t>) == true;
		};
	}

	// Forward declaration
	template<class T>
	class utf8Itterator;

	namespace detail {
		// CRTP base class storing all of the shared extensions to strings and their views
		template<typename Base, typename CharType>
		struct shared_string_extensions: public std::crtp<Base, shared_string_extensions>{
			using utf8iterator = utf8Itterator<Base>;
			using const_utf8iterator = utf8Itterator<const Base>;
			using reverse_utf8iterator = std::reverse_iterator<utf8Itterator<Base>>;
			using const_reverse_utf8iterator = std::reverse_iterator<utf8Itterator<const Base>>;

			// Null position
			static constexpr size_t npos = std::string::npos;

			// Intrinsic Coehersion to const char*
			constexpr inline operator const CharType* () const { return this->underlying().c_str(); }

			// Numeric conversions
			template <std::concepts::arithmetic T> requires std::concepts::outputable<T>
			explicit operator T () const {
				T out;
				std::stringstream s(this->underlying());
				s >> std::setprecision(std::numeric_limits<T>::max_digits10) >> out;
				return out;
			} // TODO: Provide specalized optimizations

			// Contains override
			bool contains(const Base& needle) { return this->underlying().find(needle) != npos; }

			// Caseless comparison functions
			constexpr auto caseless_compare(const std::string_view other) const {
				size_t size = std::min(this->underlying().size(), other.size());
				for(size_t i = 0; i < size; i++)
					if(std::tolower(this->underlying()[i]) != std::tolower(other[i]))
						return std::tolower(this->underlying()[i]) <=> std::tolower(other[i]);

				// If the common characters are all same then the longer string is larger
				return this->underlying().size() <=> other.size();
			}
			constexpr auto caseless_compare(const Base& other) const {
				size_t size = std::min(this->underlying().size(), other.size());
				for(size_t i = 0; i < size; i++)
					if(std::tolower(this->underlying()[i]) != std::tolower(other[i]))
						return std::tolower(this->underlying()[i]) <=> std::tolower(other[i]);

				// If the common characters are all same then the longer string is larger
				return this->underlying().size() <=> other.size();
			}
			constexpr auto caseless_compare(const char* other) const {
				size_t oSize = strlen(other);
				size_t size = std::min(this->underlying().size(), oSize);
				for(size_t i = 0; i < size; i++)
					if(std::tolower(this->underlying()[i]) != std::tolower(other[i]))
						return std::tolower(this->underlying()[i]) <=> std::tolower(other[i]);

				// If the common characters are all same then the longer string is larger
				return this->underlying().size() <=> oSize;
			}
			constexpr inline bool caseless_equal(const std::string_view other) const { return caseless_compare(other) == std::strong_ordering::equal; }
			constexpr inline bool caseless_equal(const Base& other) const { return caseless_compare(other) == std::strong_ordering::equal; }
			constexpr inline bool caseless_equal(const char* other) const { return caseless_compare(other) == std::strong_ordering::equal; }
			constexpr inline bool caseless_less(const std::string_view other) const { return caseless_compare(other) == std::strong_ordering::less; }
			constexpr inline bool caseless_less(const Base& other) const { return caseless_compare(other) == std::strong_ordering::less; }
			constexpr inline bool caseless_less(const char* other) const { return caseless_compare(other) == std::strong_ordering::less; }
			constexpr inline bool caseless_less_equal(const std::string_view other) const { auto res = caseless_compare(other); return res == std::strong_ordering::less || res == std::strong_ordering::equal; }
			constexpr inline bool caseless_less_equal(const Base& other) const { auto res = caseless_compare(other); return res == std::strong_ordering::less || res == std::strong_ordering::equal; }
			constexpr inline bool caseless_less_equal(const char* other) const { auto res = caseless_compare(other); return res == std::strong_ordering::less || res == std::strong_ordering::equal; }
			constexpr inline bool caseless_greater(const std::string_view other) const { return caseless_compare(other) == std::strong_ordering::greater; }
			constexpr inline bool caseless_greater(const Base& other) const { return caseless_compare(other) == std::strong_ordering::greater; }
			constexpr inline bool caseless_greater(const char* other) const { return caseless_compare(other) == std::strong_ordering::greater; }
			constexpr inline bool caseless_greater_equal(const std::string_view other) const { auto res = caseless_compare(other); return res == std::strong_ordering::greater || res == std::strong_ordering::equal; }
			constexpr inline bool caseless_greater_equal(const Base& other) const { auto res = caseless_compare(other); return res == std::strong_ordering::greater || res == std::strong_ordering::equal; }
			constexpr inline bool caseless_greater_equal(const char* other) const { auto res = caseless_compare(other); return res == std::strong_ordering::greater || res == std::strong_ordering::equal; }

			struct caseless_comparator {
				bool operator()(const Base& a, const Base& b) {
					return a.caseless_compare(b) == std::strong_ordering::less;
				}
			};

			constexpr inline auto natural_compare(const std::string_view other) const {
				auto ret = strnatcasecmp(this->underlying().data(), other.data());
				if (ret < 0) return std::strong_ordering::greater;
				else if(ret > 0) return std::strong_ordering::less;
				else return std::strong_ordering::equal;
			}
			constexpr inline auto natural_compare(const Base& other) const {
				auto ret = strnatcasecmp(this->underlying().data(), other.data());
				if (ret < 0) return std::strong_ordering::greater;
				else if(ret > 0) return std::strong_ordering::less;
				else return std::strong_ordering::equal;
			}
			constexpr inline auto natural_compare(const char* other) const {
				auto ret = strnatcasecmp(this->underlying().data(), other);
				if (ret < 0) return std::strong_ordering::greater;
				else if(ret > 0) return std::strong_ordering::less;
				else return std::strong_ordering::equal;
			}
			constexpr inline bool natural_equal(const std::string_view other) const { return natural_compare(other) == std::strong_ordering::equal; }
			constexpr inline bool natural_equal(const Base& other) const { return natural_compare(other) == std::strong_ordering::equal; }
			constexpr inline bool natural_equal(const char* other) const { return natural_compare(other) == std::strong_ordering::equal; }
			constexpr inline bool natural_less(const std::string_view other) const { return natural_compare(other) == std::strong_ordering::less; }
			constexpr inline bool natural_less(const Base& other) const { return natural_compare(other) == std::strong_ordering::less; }
			constexpr inline bool natural_less(const char* other) const { return natural_compare(other) == std::strong_ordering::less; }
			constexpr inline bool natural_less_equal(const std::string_view other) const { auto res = natural_compare(other); return res == std::strong_ordering::less || res == std::strong_ordering::equal; }
			constexpr inline bool natural_less_equal(const Base& other) const { auto res = natural_compare(other); return res == std::strong_ordering::less || res == std::strong_ordering::equal; }
			constexpr inline bool natural_less_equal(const char* other) const { auto res = natural_compare(other); return res == std::strong_ordering::less || res == std::strong_ordering::equal; }
			constexpr inline bool natural_greater(const std::string_view other) const { return natural_compare(other) == std::strong_ordering::greater; }
			constexpr inline bool natural_greater(const Base& other) const { return natural_compare(other) == std::strong_ordering::greater; }
			constexpr inline bool natural_greater(const char* other) const { return natural_compare(other) == std::strong_ordering::greater; }
			constexpr inline bool natural_greater_equal(const std::string_view other) const { auto res = natural_compare(other); return res == std::strong_ordering::greater || res == std::strong_ordering::equal; }
			constexpr inline bool natural_greater_equal(const Base& other) const { auto res = natural_compare(other); return res == std::strong_ordering::greater || res == std::strong_ordering::equal; }
			constexpr inline bool natural_greater_equal(const char* other) const { auto res = natural_compare(other); return res == std::strong_ordering::greater || res == std::strong_ordering::equal; }

			struct natural_comparator {
				bool operator()(const Base& a, const Base& b) {
					return a.natural_compare(b) == std::strong_ordering::less;
				}
			};

			constexpr Base ltrim (const CharType* delims = " \t\v\f\r\n") const {
				if(size_t pos = this->underlying().find_first_not_of(delims); pos != npos)
					return this->underlying().substr(pos);
				return ""; // Return null if we couldn't find any of the given things
			}
			constexpr Base rtrim (const CharType* delims = " \t\v\f\r\n") const {
				if(size_t pos = this->underlying().find_last_not_of(delims); pos != npos)
					return this->underlying().substr(0, pos + 1);
				return ""; // Return null if we couldn't find any of the given things
			}

			constexpr std::vector<Base> split (const CharType* seperators = " \t\v\f\r\n", size_t pos = 0, size_t max_splits = -1) const {
				size_t start = pos, splits = 0;
				pos = this->underlying().find_first_of(seperators, pos);
				std::vector<Base> out;

				// While there are still strings to split
				while (pos != npos && splits < max_splits) {
					if(pos - start > 0) {
						out.emplace_back(this->underlying().substr(start, pos - start));
						splits++;
					}

					start = pos + 1;
					pos = this->underlying().find_first_of(seperators, start);
				}

				out.emplace_back(this->underlying().substr(start, npos));

				return out;
			}

			// Content Check Methods
			constexpr bool isalnum() const {
				for (const CharType c: this->underlying())
					if (!isalnum(c))
						return false;
				return true;
			}

			constexpr bool isalpha() const {
				for (const CharType c: this->underlying())
					if (!isalpha(c))
						return false;
				return true;
			}

			constexpr bool isdigit() const {
				for (const CharType c: this->underlying())
					if (!isdigit(c))
						return false;
				return true;
			}

			constexpr bool islower() const {
				for (const CharType c: this->underlying())
					if (tolower(c) != c)
						return false;
				return true;
			}

			constexpr bool isspace() const {
				for (const CharType c: this->underlying())
					if (!isspace(c))
						return false;
				return true;
			}

			constexpr bool isupper() const {
				for (const CharType c: this->underlying())
					if (toupper(c) != c)
						return false;
				return true;
			}

			constexpr bool isblank() const {
				for (const CharType c: this->underlying())
					if (!isblank(c))
						return false;
				return true;
			}

			constexpr bool iscntrl() const {
				for (const CharType c: this->underlying())
					if (!iscntrl(c))
						return false;
				return true;
			}

			constexpr bool isgraph() const {
				for (const CharType c: this->underlying())
					if (!isgraph(c))
						return false;
				return true;
			}

			constexpr bool isprint() const {
				for (const CharType c: this->underlying())
					if (!isprint(c))
						return false;
				return true;
			}

			constexpr bool ispunct() const {
				for (const CharType c: this->underlying())
					if (!ispunct(c))
						return false;
				return true;
			}

			constexpr bool isxdigit() const {
				for (const CharType c: this->underlying())
					if (!isxdigit(c))
						return false;
				return true;
			}


			// -- UTF-8 --


			constexpr inline size_t length(std::utf8_t) const requires detail::is_char_8<CharType> { return utf8::distance(this->underlying().begin(), this->underlying().end()); }
			constexpr inline size_t size(std::utf8_t) const requires detail::is_char_8<CharType> { return length(std::utf8); }
			template<bool boundsCheck = true> constexpr inline Base at (std::utf8_t, size_t index) const requires detail::is_char_8<CharType> {
				if constexpr (boundsCheck)
					if(index > length(std::utf8))
						throw std::out_of_range(std::string("UTF8 index ") + std::to_string(index) + " is out of range of this string");
				return *(cbegin(std::utf8) + index);
			}
			template<bool optimize = true> constexpr inline Base front (std::utf8_t) requires detail::is_char_8<CharType> { return this->underlying().template from_utf32codepoint<optimize>(utf32codepoint()); } // TODO: this will cause issues when used on views
			constexpr inline Base back (std::utf8_t) requires detail::is_char_8<CharType> { return *end(std::utf8); }
			constexpr inline Base toupper(std::utf8_t) const requires detail::is_char_8<CharType> { return reinterpret_cast<const CharType*>(dl::detail::Utf8StrMakeUprUtf8Str( reinterpret_cast<const unsigned char*>(this->underlying().data()) )); }
			constexpr inline Base tolower(std::utf8_t) const requires detail::is_char_8<CharType> { return reinterpret_cast<const CharType*>(dl::detail::Utf8StrMakeLwrUtf8Str( reinterpret_cast<const unsigned char*>(this->underlying().data()) )); }
			constexpr inline bool utf8_valid() const requires detail::is_char_8<CharType> { return utf8::is_valid(this->underlying()); }
			constexpr inline bool valid(std::utf8_t) const requires detail::is_char_8<CharType> { return utf8_valid(); }

			constexpr inline auto caseless_compare(std::utf8_t, const Base& other) const requires detail::is_char_8<CharType> { return tolower(std::utf8).caseless_compare(other.tolower(std::utf8)); }
			constexpr inline bool caseless_equal(std::utf8_t, const Base& other) const requires detail::is_char_8<CharType> { return caseless_compare(std::utf8, other) == std::strong_ordering::equal; }
			constexpr inline bool caseless_less(std::utf8_t, const Base& other) const requires detail::is_char_8<CharType> { return caseless_compare(std::utf8, other) == std::strong_ordering::less; }
			constexpr inline bool caseless_less_equal(std::utf8_t, const Base& other) const requires detail::is_char_8<CharType> { auto res = caseless_compare(std::utf8, other); return res == std::strong_ordering::less || res == std::strong_ordering::equal; }
			constexpr inline bool caseless_greater(std::utf8_t, const Base& other) const requires detail::is_char_8<CharType> { return caseless_compare(std::utf8, other) == std::strong_ordering::greater; }
			constexpr inline bool caseless_greater_equal(std::utf8_t, const Base& other) const requires detail::is_char_8<CharType> { auto res = caseless_compare(std::utf8, other); return res == std::strong_ordering::greater || res == std::strong_ordering::equal; }

			// UTF-8 iterators
			constexpr inline utf8iterator begin (std::utf8_t) requires detail::is_char_8<CharType> { return this->underlying(); }
			constexpr utf8iterator end (std::utf8_t) requires detail::is_char_8<CharType> {
				utf8iterator out = begin(std::utf8);
				out.seekEnd();
				return out;
			}
			constexpr inline reverse_utf8iterator rbegin (std::utf8_t) requires detail::is_char_8<CharType> { return begin(std::utf8); }
			constexpr inline reverse_utf8iterator rend (std::utf8_t) requires detail::is_char_8<CharType> { return end(std::utf8); }
			constexpr inline const_utf8iterator cbegin (std::utf8_t) const requires detail::is_char_8<CharType> { return const_cast<Base>(this->underlying())->begin(std::utf8); }
			constexpr inline const_utf8iterator cend (std::utf8_t) const requires detail::is_char_8<CharType> { return const_cast<Base>(this->underlying())->end(std::utf8); }
			constexpr inline const_reverse_utf8iterator crbegin (std::utf8_t) const requires detail::is_char_8<CharType> { return cbegin(std::utf8); }
			constexpr inline const_reverse_utf8iterator crend (std::utf8_t) const requires detail::is_char_8<CharType> { return cend(std::utf8); }

			// Converts the first codepoint in the string to a u32
			constexpr inline uint32_t utf32codepoint() const requires detail::is_char_8<CharType> {
				return utf8::peek_next(this->underlying().begin(), this->underlying().end());
			}


			// -- Binary Interface --


			inline auto as_bytes() const { return std::as_bytes(std::span{this->underlying().data(), this->underlying().size()}); }
			inline auto as_writable_bytes() const { return std::as_writable_bytes(std::span{&this->underlying()[0], this->underlying().size()}); }


			// -- Pascal String --


			// Encodes a string into a pascal string
			constexpr size_t encode_pascal_string(std::byte* buffer) const requires detail::is_char_8<CharType> {
				size_t adjustedSize = calculateAdjustedSize(this->underlying().size());
				if(buffer == nullptr) return adjustedSize;

				uint8_t dataOffset = setLeadingBytes(this->underlying().size(), buffer);

				memcpy(buffer + dataOffset, this->underlying().data(), this->underlying().size() * sizeof(CharType));
				return adjustedSize;
			}
			std::vector<std::byte> pascal_string() const requires detail::is_char_8<CharType>{
				size_t outSize = encode_pascal_string(nullptr);
				std::vector<std::byte> out(outSize);
				encode_pascal_string(&out[0]);
				return out;
			}

			// Writes a pascal string to an output stream
			constexpr std::ostream& pascal_string(std::ostream& stream) const requires detail::is_char_8<CharType> {
				std::byte buffer[8];
				uint8_t dataOffset = setLeadingBytes(this->underlying().size(), buffer);
				stream.write((char*) buffer, dataOffset);
				stream.write((char*) this->underlying().data(), this->underlying().size());

				return stream;
			}

		protected:
			// Calculates size include std::bytes storing size
			inline static size_t calculateAdjustedSize (size_t rawSize) noexcept {
				if(rawSize < (1 << 6) /*2^6*/)
					return rawSize + 1;
				else if (rawSize < (1 << 14) /*2^14*/)
					return rawSize + 2;
				else if (rawSize < (1 << 30) /*2^30*/)
					return rawSize + 4;
				else if (rawSize < (1ull << 62) /*2^62*/)
					return rawSize + 8;
				return 0;
			}

			// Sets the leading std::bytes of the provided buffer so that they represent the string's size
			inline static uint8_t setLeadingBytes (uint64_t rawSize, std::byte* buffer) noexcept {
				// TODO: need to worry about the endianess of the data?
				if(rawSize < (1 << 6) /*2^6*/) {
					((uint8_t*) buffer)[0] = std::convert_little_endian(uint8_t(rawSize)) << 2;
					// No need to set the std::byte count bits, they are already 00 like they should be
					return 1;
				} else if (rawSize < (1 << 14) /*2^14*/) {
					((uint16_t*) buffer)[0] = std::convert_little_endian(uint16_t(rawSize)) << 2;
					((uint8_t*) buffer)[0] |= 0b01;
					return 2;
				} else if (rawSize < (1 << 30) /*2^30*/) {
					((uint32_t*) buffer)[0] = std::convert_little_endian(uint32_t(rawSize)) << 2;
					((uint8_t*) buffer)[0] |= 0b10;
					return 4;
				} else if (rawSize < (1ull << 62) /*2^62*/) {
					((uint64_t*) buffer)[0] = std::convert_little_endian(rawSize) << 2ull;
					((uint8_t*) buffer)[0] |= 0b11;
					return 8;
				}
				return 0;
			}

			// Gets the number the bits representing how many std::bytes are used to store the size
			inline static uint8_t getByteCountBits (const std::byte* data) noexcept { return uint8_t(data[0]) & 0b00000011; }
			// Gets the number of std::bytes used to store the size
			inline static uint8_t getDataOffset (const std::byte* data) noexcept { return 1 << getByteCountBits(data); }

			// Converts the size std::bytes into a valid size
			inline static uint64_t decodeSize (const std::byte* data) noexcept {
				switch(getByteCountBits(data)) {
				case 0:
					return std::convert_little_endian(uint8_t(((uint8_t*) data)[0] >> 2));
				case 1:
					return std::convert_little_endian(uint16_t(((uint16_t*) data)[0] >> 2));
				case 2:
					return std::convert_little_endian(uint32_t(((uint32_t*) data)[0] >> 2));
				case 3:
					return std::convert_little_endian(uint64_t(((uint64_t*) data)[0] >> 2ull));
				}
				return 0;
			}

		};
	}

	// Non-owning view of a string
	template<class CharType, class Traits = std::char_traits<CharType>>
	class basic_string_view: public std::basic_string_view<CharType, Traits>, public detail::shared_string_extensions<basic_string_view<CharType, Traits>, CharType> {
		using Base = std::basic_string_view<CharType, Traits>;
		using Ext = detail::shared_string_extensions<basic_string_view<CharType, Traits>, CharType>;
	public:
		using legacy = Base;
		using view = Base;

		using Base::Base;
		// Include all of the relevant using statements from the bass class
		using value_type = typename Base::value_type;
		using traits_type = typename Base::traits_type;
		using reference = typename Base::reference;
		using const_reference = typename Base::const_reference;
		using pointer = typename Base::pointer;
		using const_pointer = typename Base::const_pointer;
		using iterator = typename Base::iterator;
		using const_iterator = typename Base::const_iterator;
		using reverse_iterator = typename Base::reverse_iterator;
		using const_reverse_iterator = typename Base::const_reverse_iterator;
		using utf8iterator = typename Ext::utf8iterator;
		using const_utf8iterator = typename Ext::const_utf8iterator;
		using reverse_utf8iterator = typename Ext::reverse_utf8iterator;
		using const_reverse_utf8iterator = typename Ext::const_reverse_utf8iterator;
		using difference_type = typename Base::difference_type;
		using size_type = typename Base::size_type;

		// Usings to explicity pull in conflicting functions for disambiguation
		using Ext::contains;
		using Base::length;
		using Ext::length;
		using Base::size;
		using Ext::size;
		using Base::at;
		using Ext::at;
		using Base::front;
		using Ext::front;
		using Base::back;
		using Ext::back;
		using Base::begin;
		using Ext::begin;
		using Base::end;
		using Ext::end;
		using Base::rbegin;
		using Ext::rbegin;
		using Base::rend;
		using Ext::rend;
		using Base::cbegin;
		using Ext::cbegin;
		using Base::cend;
		using Ext::cend;
		using Base::crbegin;
		using Ext::crbegin;
		using Base::crend;
		using Ext::crend;
		using Ext::toupper;
		using Ext::tolower;

		using Ext::caseless_comparator;
		using Ext::natural_comparator;

		// Intrinsic Coehersion from std::string's
		constexpr basic_string_view(const std::string& base) : Base(base) {}
		constexpr basic_string_view(const std::string&& base) : Base(base) {}
		// Intrinsic Coehersion to std::string's
		inline operator std::string() { return *this; }
		inline operator const std::string() const { return *this; }

		// Intrinsic Coehersion from std::string_view's
		constexpr basic_string_view(const std::string_view& base) : Base(base) {}
		constexpr basic_string_view(const std::string_view&& base) : Base(base) {}
		// Intrinsic Coehersion to std::string_view's
		inline operator std::string_view() { return *this; }
		inline operator const std::string_view() const { return *this; }

		using Base::operator[];
		constexpr inline basic_string_view operator[](std::slice s) { 
			if(s.stride() != 1) throw std::invalid_argument("DuckLib types currently only support slices with a stride of 1!");
			return {this->data() + s.start(), s.size()};
		}
		constexpr inline basic_string_view operator[](dl::slice s) { 
			return this->operator[](s.apply_size(this->size()));
		}

		constexpr basic_string_view trim(const CharType* delims = " \t\v\f\r\n") const {
			basic_string_view l = this->ltrim(delims);
			size_t pos = l.data() - Base::data();
			return this->substr(pos, this->rtrim(delims).size() - pos );
		}

		static inline basic_string_view from_bytes(const std::span<std::byte> bytes) { return {(const char*) bytes.data(), bytes.size()}; }
	};

	template<typename CharType, typename Traits = std::char_traits<CharType>, typename Alloc = std::allocator<CharType> >
	class basic_string: public std::basic_string<CharType, Traits, Alloc>, public detail::shared_string_extensions<basic_string<CharType, Traits, Alloc>, CharType> {
		using Base = std::basic_string<CharType, Traits, Alloc>;
		using Ext = detail::shared_string_extensions<basic_string<CharType, Traits>, CharType>;
	public:
		using view = basic_string_view<CharType, Traits>;
		using slice = view;
		// Legacy string support
		using legacy = std::basic_string<CharType, Traits, Alloc>;

		using Base::npos;
		using Base::Base;

		// Include all of the relevant using statements from the bass class
		using value_type = typename Base::value_type;
		using traits_type = typename Base::traits_type;
		using allocator_type = typename Base::allocator_type;
		using reference = typename Base::reference;
		using const_reference = typename Base::const_reference;
		using pointer = typename Base::pointer;
		using const_pointer = typename Base::const_pointer;
		using iterator = typename Base::iterator;
		using const_iterator = typename Base::const_iterator;
		using reverse_iterator = typename Base::reverse_iterator;
		using const_reverse_iterator = typename Base::const_reverse_iterator;
		using utf8iterator = typename Ext::utf8iterator;
		using const_utf8iterator = typename Ext::const_utf8iterator;
		using reverse_utf8iterator = typename Ext::reverse_utf8iterator;
		using const_reverse_utf8iterator = typename Ext::const_reverse_utf8iterator;
		using difference_type = typename Base::difference_type;
		using size_type = typename Base::size_type;

		// Usings to explicity pull in conflicting functions for disambiguation
		using Ext::contains;
		using Base::length;
		using Ext::length;
		using Base::size;
		using Ext::size;
		using Base::at;
		using Ext::at;
		using Base::front;
		using Ext::front;
		using Base::back;
		using Ext::back;
		using Base::begin;
		using Ext::begin;
		using Base::end;
		using Ext::end;
		using Base::rbegin;
		using Ext::rbegin;
		using Base::rend;
		using Ext::rend;
		using Base::cbegin;
		using Ext::cbegin;
		using Base::cend;
		using Ext::cend;
		using Base::crbegin;
		using Ext::crbegin;
		using Base::crend;
		using Ext::crend;
		using Ext::toupper;
		using Ext::tolower;

		using Ext::caseless_comparator;
		using Ext::natural_comparator;

		// Intrinsic Coehersion from char
		constexpr basic_string(const CharType c) : Base(1, c) {}
		// Intrinsic Coehersion from std::string's
		constexpr basic_string(const std::basic_string<CharType, Traits, Alloc>& base) : Base(base) {}
		constexpr basic_string(const std::basic_string<CharType, Traits, Alloc>&& base) : Base(base) {}
		// Intrinsic Coehersion to std::string's
		inline operator std::basic_string<CharType, Traits, Alloc>() { return *this; }
		inline operator const std::basic_string<CharType, Traits, Alloc>() const { return *this; }

		// Intrinsic Coehersion from std::string_view's
		constexpr basic_string(const std::basic_string_view<CharType, Traits>& base) : Base(base) {}
		constexpr basic_string(const std::basic_string_view<CharType, Traits>&& base) : Base(base) {}

		using Base::operator[];
		constexpr inline view operator[](std::slice s) { 
			if(s.stride() != 1) throw std::invalid_argument("DuckLib types currently only support slices with a stride of 1!");
			return {Base::data() + s.start(), s.size()};
		}
		constexpr inline view operator[](dl::slice s) { 
			return this->operator[](s.apply_size(this->size()));
		}

		// Gets a String View of this string
		constexpr inline view substr_view(size_t pos = 0, size_t len = npos) const {
			if(len == npos) len = Base::size() - pos;
			return {Base::data() + pos, len};
		}

		constexpr inline basic_string substr(size_t pos = 0, size_t len = npos) const {
			return Base::substr(pos, len);
		}

		// Implicitly convert to string_view's
		constexpr inline operator view() const { return substr_view(); }

		// Support appending a string_view or const char* to a string
		// constexpr inline basic_string operator+(const std::basic_string_view<CharType, Traits> other) const { auto out = *this; out.append(other.data(), other.size()); return out; }
		constexpr inline basic_string& operator+=(const std::basic_string_view<CharType, Traits> other) { Base::append(other.data(), other.size()); return *this; }

		// Support appending a single char to the string
		constexpr inline basic_string operator+(const CharType other) const { auto out = *this; out.append(1, other); return out; }
		constexpr inline basic_string& operator+=(const CharType other) { Base::append(1, other); return *this; }

		// Update replace to match naming specifications (original functions result in a copy)
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, const Base& str) { return Base::replace(pos, len, str); }
		constexpr inline basic_string replace (std::modify_original_t, const_iterator i1, const_iterator i2, const Base& str) { return Base::replace(i1, i2, str); }
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, const Base& str, size_t subpos, size_t sublen = npos) { return Base::replace(pos, len, str, subpos, sublen); }
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, const view& str) { return Base::replace(pos, len, Base(str)); }
		constexpr inline basic_string replace (std::modify_original_t, const_iterator i1, const_iterator i2, const view& str) { return Base::replace(i1, i2, Base(str)); }
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, const view& str, size_t subpos, size_t sublen = npos) { return Base::replace(pos, len, Base(str), subpos, sublen); }
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, const CharType* s) { return Base::replace(pos, len, s); }
		constexpr inline basic_string replace (std::modify_original_t, const_iterator i1, const_iterator i2, const CharType* s) { return Base::replace(i1, i2, s); }
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, const CharType* s, size_t n) { return Base::replace(pos, len, s, n); }
		constexpr inline basic_string replace (std::modify_original_t, const_iterator i1, const_iterator i2, const CharType* s, size_t n) { return Base::replace(i1, i2, s, n); }
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, size_t n, char c) { return Base::replace(pos, len, n, c); }
		constexpr inline basic_string replace (std::modify_original_t, const_iterator i1, const_iterator i2, size_t n, char c) { return Base::replace(i1, i2, n, c); }
		template <class InputIterator> constexpr inline basic_string replace(std::modify_original_t, const_iterator i1, const_iterator i2, InputIterator first, InputIterator last) { return Base::replace(i1, i2, first, last); }
		constexpr inline basic_string replace (std::modify_original_t, const_iterator i1, const_iterator i2, std::initializer_list<char> il) { return Base::replace(i1, i2, il); }
		constexpr inline basic_string replace (std::modify_original_t, size_t pos, size_t len, const Base& str) const {
			basic_string out = *this;
			return out.replace(std::modify_original, pos, len, str);
		}
		constexpr inline basic_string replace (const_iterator i1, const_iterator i2, const Base& str) const {
			basic_string out = *this;
			return out.replace(std::modify_original, i1, i2, str);
		}
		constexpr inline basic_string replace (size_t pos, size_t len, const Base& str, size_t subpos, size_t sublen = npos) const {
			basic_string out = *this;
			return out.replace(std::modify_original, pos, len, str, subpos, sublen);
		}
		constexpr inline basic_string replace (size_t pos, size_t len, const view& str) const {
			basic_string out = *this;
			return out.replace(std::modify_original, pos, len, Base(str));
		}
		constexpr inline basic_string replace (const_iterator i1, const_iterator i2, const view& str) const {
			basic_string out = *this;
			return out.replace(std::modify_original, i1, i2, Base(str));
		}
		constexpr inline basic_string replace (size_t pos, size_t len, const view& str, size_t subpos, size_t sublen = npos) const {
			basic_string out = *this;
			return out.replace(std::modify_original, pos, len, Base(str), subpos, sublen);
		}
		constexpr inline basic_string replace (size_t pos, size_t len, const CharType* s) const {
			basic_string out = *this;
			return out.replace(std::modify_original, pos, len, s);
		}
		constexpr inline basic_string replace (const_iterator i1, const_iterator i2, const CharType* s) const {
			basic_string out = *this;
			return out.replace(std::modify_original, i1, i2, s);
		}
		constexpr inline basic_string replace (size_t pos, size_t len, const CharType* s, size_t n) const {
			basic_string out = *this;
			return out.replace(std::modify_original, pos, len, s, n);
		}
		constexpr inline basic_string replace (const_iterator i1, const_iterator i2, const CharType* s, size_t n) const {
			basic_string out = *this;
			return out.replace(std::modify_original, i1, i2, s, n);
		}
		constexpr inline basic_string replace (size_t pos, size_t len, size_t n, char c) const {
			basic_string out = *this;
			return out.replace(std::modify_original, pos, len, n, c);
		}
		constexpr inline basic_string replace (const_iterator i1, const_iterator i2, size_t n, char c) const {
			basic_string out = *this;
			return out.replace(std::modify_original, i1, i2, n, c);
		}
		template <class InputIterator> constexpr inline basic_string replace (const_iterator i1, const_iterator i2, InputIterator first, InputIterator last) const {
			basic_string out = *this;
			return out.replace(std::modify_original, i1, i2, first, last);
		}
		constexpr inline basic_string replace (const_iterator i1, const_iterator i2, std::initializer_list<char> il) const {
			basic_string out = *this;
			return out.replace(std::modify_original, i1, i2, il);
		}


		// NOTE: all methods return the changes applied to a copied string, except *_original methods apply changes to the original string and are garunteed not to create a copy


		// Search and substitute methods.
		constexpr basic_string& replace_first(std::modify_original_t, const view& toFind, const view& toReplace, size_t pos = 0) {
			pos = Base::find(toFind, pos);
			if (pos == npos) return *this;

	 		replace(std::modify_original, pos, toFind.size(), toReplace);
			return *this;
		}
		constexpr inline basic_string replace_first(const view& toFind, const view& toReplace, size_t pos = 0) const {
			basic_string out = *this;
			return out.replace_first(std::modify_original, toFind, toReplace, pos);
		}

		constexpr basic_string& replace(std::modify_original_t, const view& toFind, const view& toReplace, size_t pos = 0, size_t maxReplacements = -1) {
			pos = Base::find(toFind, pos);
			for(size_t count = 0; pos != npos && count < maxReplacements; count++) {
				replace(std::modify_original, pos, toFind.size(), toReplace);
				pos = Base::find(toFind, pos + toReplace.size());
			}
			return *this;
		}
		constexpr inline basic_string replace(const view& toFind, const view& toReplace, size_t pos = 0, size_t maxReplacements = -1) const {
			basic_string out = *this;
			return out.replace(std::modify_original, toFind, toReplace, pos, maxReplacements);
		}

		constexpr size_t count(const view& needle, size_t pos = 0) const {
			pos = Base::find(needle, pos);
			size_t count = 0;
			while(pos != npos) {
				count ++;
				pos = Base::find(needle, pos + needle.size());
			}

			return count;
		}


		// // Miscellaneous methods.
		constexpr basic_string repeat (std::modify_original_t, size_t count) {
			resize(count * Base::size() + 1);
			CharType* buffer = &(*this)[1];
			size_t segmentLength = Base::size();
			for(int i = 0; i < count; i++, buffer += segmentLength)
				memcpy(buffer, Base::data(), segmentLength);

			return *this;
		}
		constexpr basic_string repeat (size_t count) const {
			basic_string out = *this;
			return out.repeat(std::modify_original, count);
		}

		constexpr view ltrim_view (const CharType* delims = " \t\v\f\r\n") const {
			if(size_t pos = Base::find_first_not_of(delims); pos != npos)
				return substr_view(pos);
			return ""; // Return a null if we couldn't find any of the given things
		}
		constexpr view rtrim_view (const CharType* delims = " \t\v\f\r\n") const {
			if(size_t pos = Base::find_last_not_of(delims); pos != npos)
				return substr_view(0, pos + 1);
			return ""; // Return a null if we couldn't find any of the given things
		}
		constexpr inline Base trim (const CharType* delims = " \t\v\f\r\n") const {
			return this->ltrim(delims).rtrim(delims);
		}
		constexpr view trim_view(const CharType* delims = " \t\v\f\r\n") const {
			view l = ltrim_view(delims);
			size_t pos = l.data() - Base::data();
			return substr_view(pos, rtrim_view(delims).size() - pos );
		}

		constexpr std::vector<view> split_view (const CharType* seperators = " \t\v\f\r\n", size_t pos = 0, size_t max_splits = -1) const {
			size_t start = pos, splits = 0;
			pos = Base::find_first_of(seperators, pos);
			std::vector<view> out;

			// While there are still strings to split
			while (pos != npos && splits < max_splits) {
				if(pos - start > 0) {
					out.emplace_back(substr_view(start, pos - start));
					splits++;
				}

				start = pos + 1;
				pos = Base::find_first_of(seperators, start);
			}

			out.emplace_back(Base::substr_view(start, npos));

			return out;
		}

		constexpr basic_string& toupper (std::modify_original_t) {
			for(size_t i = 0; i < Base::size(); i++)
				Base::operator[](i) = std::toupper((unsigned char)Base::operator[](i));
			return *this;
		}
		constexpr inline basic_string toupper() const {
			basic_string out = *this;
			return out.toupper(std::modify_original);
		}

		constexpr basic_string& tolower(std::modify_original_t) {
			for(size_t i = 0; i < Base::size(); i++)
				Base::operator[](i) = std::tolower((unsigned char)Base::operator[](i));
			return *this;
		}
		constexpr inline basic_string tolower() const {
			basic_string out = *this;
			return out.tolower(std::modify_original);
		}

		constexpr basic_string& totitle (std::modify_original_t, const CharType* seperators = " \t\v\f\r\n") {
			tolower(std::modify_original);
			for(size_t pos = Base::find_first_of(seperators); pos != npos; pos = Base::find_first_of(seperators, pos + 1))
				if(pos + 1 < Base::size())
					Base::operator[](pos + 1) = std::toupper((unsigned char)Base::operator[](pos + 1));
			return *this;
		}
		constexpr inline basic_string totitle(const CharType* seperators = " \t\v\f\r\n") const {
			basic_string out = *this;
			return out.totitle(std::modify_original, seperators);
		}

		constexpr basic_string& center (std::modify_original_t, size_t width, char fill = ' ') {
			if (Base::size() > width) return *this; // If the width is smaller than the string nothing happens

			size_t diff = width - Base::size();
			size_t leftPadding = diff / 2;
			size_t rightPadding = diff - leftPadding;

			if(leftPadding > 0) Base::insert(0, leftPadding, fill);
			if(rightPadding > 0) Base::insert(Base::size(), rightPadding, fill);

			return *this;
		}
		constexpr inline basic_string center(size_t width, char fill = ' ') const {
			basic_string out = *this;
			return out.center(std::modify_original, width, fill);
		}
		constexpr basic_string center_multiline(size_t width, char fill = ' ', size_t pos = 0, size_t max_splits = -1) const {
			std::vector<basic_string> splits = Ext::split("\r\n", pos, max_splits);
			basic_string out;
			for(basic_string& str: splits) out += str.center(std::modify_original, width, fill) + '\n';
			return out;
		}

		constexpr basic_string& left (std::modify_original_t, size_t width, char fill = ' ') {
			if (Base::size() > width) return *this; // If the width is smaller than the string nothing happens

			size_t diff = width - Base::size();
			if(diff > 0) Base::insert(Base::size(), diff, fill);

			return *this;
		}
		constexpr inline basic_string left(size_t width, char fill = ' ') const {
			basic_string out = *this;
			return out.left(std::modify_original, width, fill);
		}
		constexpr basic_string left_multiline(size_t width, char fill = ' ', size_t pos = 0, size_t max_splits = -1) const {
			std::vector<basic_string> splits = Ext::split("\r\n", pos, max_splits);
			basic_string out;
			for(basic_string& str: splits) out += str.left(std::modify_original, width, fill) + '\n';
			return out;
		}

		constexpr basic_string& right (std::modify_original_t, size_t width, char fill = ' ') {
			if (Base::size() > width) return *this; // If the width is smaller than the string nothing happens

			size_t diff = width - Base::size();
			if(diff > 0) Base::insert(0, diff, fill);

			return *this;
		}
		constexpr inline basic_string right(size_t width, char fill = ' ') const {
			basic_string out = *this;
			return out.right(std::modify_original, width, fill);
		}
		constexpr basic_string right_multiline(size_t width, char fill = ' ', size_t pos = 0, size_t max_splits = -1) const {
			std::vector<basic_string> splits = Ext::split("\r\n", pos, max_splits);
			basic_string out;
			for(basic_string& str: splits) out += str.right(std::modify_original, width, fill) + '\n';
			return out;
		}


#define DUCKED_C_STRING_JOIN_IMPL if(strings.size() == 0) return "";\
\
			auto i = strings.begin();\
			basic_string out = *i;\
			++i;\
\
			for(; i != strings.end(); ++i)\
				out += *this + *i;\
			return out;

		constexpr basic_string join(std::span<std::string_view> strings) const { DUCKED_C_STRING_JOIN_IMPL }
		constexpr basic_string join(std::span<std::string> strings) const { DUCKED_C_STRING_JOIN_IMPL }
		constexpr basic_string join(std::span<basic_string> strings) const { DUCKED_C_STRING_JOIN_IMPL }
		constexpr basic_string join(std::span<view> strings) const { DUCKED_C_STRING_JOIN_IMPL }
#undef DUCKED_C_STRING_JOIN_IMPL


		// -- UTF-8/32 --


		// Gets a string from a u32 codepoint
		template<bool optimize = true>
		constexpr static basic_string from_utf32codepoint(uint32_t codePoint) requires detail::is_char_8<CharType> {
			basic_string out;
			out.resize(5);
			utf8::append(codePoint, out.begin());

			// If we should optimize... remove any unessicary characters from the end of the string
			if constexpr (optimize) {
				while(out.back() == '\0') out.erase(out.size() - 1);
				out.shrink_to_fit();
			}

			return out;
		}


		// -- Binary Interface --


		static inline basic_string from_bytes(const std::span<std::byte> bytes) { return view::from_bytes(bytes); }


		// -- Pascal String --


		// Decodes a pascal string into a string
		constexpr static basic_string decode_pascal_string(const std::byte* pascal) requires detail::is_char_8<CharType> {
			size_t size = Ext::decodeSize(pascal);
			basic_string out(size, '\0');
			memcpy(&out[0], pascal + Ext::getDataOffset(pascal), size);
			return out;
		}
		static basic_string pascal_string(const std::vector<std::byte> pascal) requires detail::is_char_8<CharType> { return decode_pascal_string(pascal.data()); }

		// Reads a pascal string from an input stream
		constexpr static basic_string pascal_string(std::istream& stream) requires detail::is_char_8<CharType> {
			std::byte buffer[8] = {(std::byte)stream.get(), std::byte{}, std::byte{}, std::byte{}, std::byte{}, std::byte{}, std::byte{}, std::byte{}};
			uint8_t dataOffset = Ext::getDataOffset(buffer);

			if(dataOffset > 1) stream.read((char*)buffer + 1, dataOffset - 1);
			size_t size = Ext::decodeSize(buffer);

			basic_string out(size, '\0');
			stream.read(&out[0], size);
			return out;
		}


		// Static constructors
		template<class ... Args>
		static basic_string format(const CharType* fmt, Args... args) {
			// Caclulate the size of the generated string
			size_t size = snprintf(nullptr, 0, fmt, args...);
			// Reserve enouph space for it and then store it
			basic_string out(size, '\0');
			snprintf(&out[0], size, fmt, args...);
			return out;
		};
	};

	// Support for rhs addition with const char* and std::string_view
	template<typename C, typename T, typename A> constexpr inline basic_string<C, T, A> operator+(const C* a, const basic_string<C, T, A>& b) { return basic_string<C, T, A>(a) + b; }
	template<typename C, typename T, typename A> constexpr inline basic_string<C, T, A> operator+(const std::basic_string_view<C, T> a, const basic_string<C, T, A>& b) { return basic_string<C, T, A>(a) + b; }
	template<typename C, typename T, typename A> constexpr inline basic_string<C, T, A> operator+(const std::basic_string_view<C, T> a, const basic_string<C, T, A>&& b) { return basic_string<C, T, A>(a) + b; }

	template<class T>
	class utf8Itterator {
		T* referencedString;
		typename T::iterator iterator;
		using allocatedString = basic_string<typename T::value_type, typename T::traits_type>;

	public:
		using iterator_category = std::random_access_iterator_tag;
		using value_type = T;
		using difference_type = std::ptrdiff_t;
		using pointer = T*;
		using reference = T&;

		class CodePointWrapper {
			const utf8Itterator& owner;
			size_t pos;

		public:
			constexpr CodePointWrapper(const utf8Itterator& owner, size_t pos) : owner(owner), pos(pos) {}

			constexpr void setOwnerCodePoint(uint32_t cp) {
				// Ensure that the place in the owning string has the correct length
				int8_t diff = utf8::internal::sequence_length(&cp) - utf8::internal::sequence_length(owner.iterator[pos]);
				if(diff > 0) owner.referencedString->insert(pos, diff, '\0');
				else if(diff < 0) owner.referencedString->erase(pos, -diff);

				utf8::append(cp, owner.iterator.begin() + pos);
			}

			constexpr inline CodePointWrapper& operator=(uint32_t cp) { setOwnerCodePoint(cp); }
			constexpr inline CodePointWrapper& operator=(T& str) { setOwnerCodePoint(str.u32codepoint()); }

			constexpr inline operator allocatedString() const { return allocatedString::from_utf32codepoint(operator uint32_t()); }
			constexpr inline operator uint32_t() const { return utf8::peek_next(owner.referencedString->begin() + pos, owner.referencedString->end()); }
			constexpr inline allocatedString unoptimizedString() const { return allocatedString::template from_utf32codepoint<false>(operator uint32_t()); }

		};

		constexpr utf8Itterator() : referencedString(nullptr) {}
		constexpr utf8Itterator(T& _referencedString) : referencedString(&_referencedString), iterator(_referencedString.begin()) {}
		constexpr utf8Itterator(const utf8Itterator<T>& o) { *this = o; }
		constexpr inline utf8Itterator& operator=(const utf8Itterator<T>& o) {
			referencedString = o.referencedString;
			iterator = o.iterator;

			return *this;
		}
		constexpr utf8Itterator(utf8Itterator<T>&& o) { *this = std::move(o); }
		constexpr inline utf8Itterator& operator=(utf8Itterator<T>&& o) {
			referencedString = std::move(o.referencedString);
			iterator = std::move(o.iterator);

			return *this;
		}

		constexpr inline void setString(T& _referencedString) {
			referencedString = _referencedString;
			iterator = _referencedString->begin();
		}
		constexpr inline void setString(T&& _referencedString) { setString(_referencedString); }

		constexpr void seekEnd(size_t end = -1) {
			if(end == -1ul)
				end = utf8::distance(referencedString->begin(), referencedString->end());

			iterator = referencedString->begin();
			operator += (end - 1);
		}

		constexpr inline utf8Itterator& operator++() {
			utf8::next(iterator, referencedString->end());
			return *this;
		}
		constexpr inline utf8Itterator operator++(int) {
			utf8Itterator temp = *this;
			utf8::next(iterator, referencedString->end());
			return temp;
		}

		constexpr inline std::partial_ordering operator<=>(const utf8Itterator<T>& o) const {
			if(referencedString == nullptr || o.referencedString == nullptr) return std::partial_ordering::unordered;
			if(referencedString != o.referencedString) return std::partial_ordering::unordered;

			return iterator <=> o.iterator;
		}

		constexpr inline bool operator==(const utf8Itterator<T>& o) const {
			if(referencedString != o.referencedString) return false;

			return iterator == o.iterator;
		}

		constexpr inline CodePointWrapper operator*() { return CodePointWrapper(*this, iterator - referencedString->begin()); }
		constexpr inline const CodePointWrapper operator*() const { return CodePointWrapper(*this, iterator - referencedString->begin()); }
		constexpr inline CodePointWrapper operator->() { return CodePointWrapper(*this, iterator - referencedString->begin()); } // TODO: Should have?
		constexpr inline const CodePointWrapper operator->() const { return CodePointWrapper(*this, iterator - referencedString->begin()); } // TODO: Should have?

		constexpr inline utf8Itterator& operator--() {
			utf8::prior(iterator, referencedString->begin());
			return *this;
		}
		constexpr inline utf8Itterator operator--(int) {
			utf8Itterator temp = *this;
			utf8::prior(iterator, referencedString->begin());
			return temp;
		}

		constexpr inline utf8Itterator& operator+= (const size_t ammount) {
			utf8::advance(iterator, ammount, referencedString->end());
			return *this;
		}
		constexpr inline utf8Itterator operator+ (const size_t ammount) const {
			utf8Itterator out = *this;
			return out += ammount;
		}
		constexpr inline utf8Itterator& operator+= (const utf8Itterator& other) {
			utf8::advance(iterator, utf8::distance(other.referencedString->begin(), other.iterator), referencedString->end());
			return *this;
		}
		constexpr inline utf8Itterator operator+ (const utf8Itterator& other) const {
			utf8Itterator out = *this;
			return out += other;
		}

		constexpr inline utf8Itterator& operator-= (const size_t ammount) {
			utf8::advance(iterator, -ammount, referencedString->begin());
			return *this;
		}
		constexpr inline utf8Itterator operator- (const size_t ammount) const {
			utf8Itterator out = *this;
			return out += ammount;
		}
		constexpr inline utf8Itterator& operator-= (const utf8Itterator& other) {
			utf8::advance(iterator, -utf8::distance(other.referencedString->begin(), other.iterator), referencedString->end());
			return *this;
		}
		constexpr inline utf8Itterator operator- (const utf8Itterator& other) const {
			utf8Itterator out = *this;
			return out += other;
		}

		constexpr inline CodePointWrapper operator[](typename allocatedString::iterator::difference_type diff) { utf8::advance(iterator, diff, (diff > 0 ? referencedString->end() : referencedString->begin()) ); }
		constexpr inline const CodePointWrapper operator[](typename allocatedString::iterator::difference_type diff) const { utf8::advance(iterator, diff, (diff > 0 ? referencedString->end() : referencedString->begin()) ); }
	};

	template<class T> constexpr inline utf8Itterator<T>& operator+ (const size_t ammount, const utf8Itterator<T>& it) { return it + ammount; }

	// Define a string as a basic string operating on chars
	typedef basic_string<char> string;
}

// Define literal extensions for string and string view
namespace dl::literals {
	inline dl::string operator"" s(const char* x, size_t len) { return {x, len}; }
	inline dl::string::view operator"" sv(const char* x, size_t len) { return {x, len}; }
}

#endif // ___DUCKED_C_STRING_HPP___
