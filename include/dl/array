#ifndef ___DUCKED_C_ARRAY_HPP___
#define ___DUCKED_C_ARRAY_HPP___
#include <array>
#include <tuple>
#include <vector>
#include <span>
#include <string>
#include "binary"

#include <experimental/mdspan>
#include <experimental/mdarray>

namespace dl {
	template<typename T, size_t size>
	struct array: public std::array<T, size> {
		using legacy = std::array<T, size>;
		using legacy::legacy;

		using slice = std::span<T, size>;
		static constexpr size_t extent = size;

		// Constructor which initializes the array with the given value
		constexpr array(const T& default_) : legacy(fillInitialize(default_)) {}
		constexpr array(const T&& default_) : array(default_) {}

		// Function whichs finds an element in the array
		constexpr auto find(const T& needle) const {
			for(auto cur = legacy::begin(), end = legacy::end(); cur != end; cur++)
				if(*cur == needle)
					return cur;

			return legacy::end();
		}
		constexpr inline auto find(const T&& needle) const { return find(needle); }

		// Function which checks if the array contains a value
		constexpr inline auto contains(const T& needle) const { return find(needle) != legacy::end(); }
		constexpr inline auto contains(const T&& needle) const { return find(needle) != legacy::end(); }

		inline auto as_bytes() const {
			std::array<std::byte, sizeof(T) * size> out;
			size_t b = 0;

			for(auto& c: *this)
				for(auto byte: std::as_bytes(c))
					out[b++] = byte;

			return out;
		}
		inline auto as_writable_bytes() const = delete;

		static inline auto from_bytes(const std::span<std::byte> _bytes) {
			array out;
			std::span<std::byte> bytes = _bytes;

			for(size_t i = 0; i < size; i++) {
				out[i] = std::move(std::from_bytes<T>(bytes)); // TODO: Should this move or copy?
				bytes = std::span{bytes.data() + sizeof(T), bytes.size() - sizeof(T)};
			}

			return out;
		}

	private:
		// Function which initializes an std::array filled with the given value
		constexpr static legacy fillInitialize(const T& value) {
			constexpr auto arrayGenerator = []<size_t... I>(const T& value, std::integer_sequence<size_t, I...> s) {
				constexpr auto fillGenerator = [](size_t _, const T& value) { return value; };
				return std::array<T, sizeof...(I)> { fillGenerator(I, value)... };
			};

			return arrayGenerator(value, std::make_index_sequence<size>{});
		}
	};

	template<class T, class Allocator = std::allocator<T>>
	class vector: public std::vector<T, Allocator> {
		using legacy = std::vector<T, Allocator>;
		using legacy::legacy;

		using slice = std::span<T, std::dynamic_extent>;

		// Function whichs finds an element in the array
		constexpr auto find(const T& needle) const {
			for(auto cur = legacy::begin(), end = legacy::end(); cur != end; cur++)
				if(*cur == needle)
					return cur;

			return legacy::end();
		}
		constexpr inline auto find(const T&& needle) const { return find(needle); }

		// Function which checks if the array contains a value
		constexpr inline auto contains(const T& needle) const { return find(needle) != legacy::end(); }
		constexpr inline auto contains(const T&& needle) const { return find(needle) != legacy::end(); }

		// Fills the array with a value
		constexpr inline void fill(const T& value) { std::fill(legacy::begin(), legacy::end(), value); }

		inline auto as_bytes() const {
			std::vector<std::byte> out;
			out.reserve(sizeof(size_t) + legacy::size() * sizeof(T));

			size_t size = legacy::size();
			for(auto byte: std::as_writable_bytes(size))
				out.push_back(byte);

			for(auto& c: *this)
				for(auto byte: std::as_bytes(c))
					out.push_back(byte);

			return out;
		}
		inline auto as_writable_bytes(std::vector<T>& data) const = delete;

		static inline auto from_bytes(const std::span<std::byte> _bytes) {
			size_t size = std::from_bytes<size_t>(_bytes);
			vector out;
			out.reserve(size);

			auto bytes = std::span{_bytes.data() + sizeof(size_t), _bytes.size() - sizeof(size_t)};
			for(size_t i = 0; i < size; i++) {
				out.emplace_back(std::move(std::from_bytes<T>(bytes))); // TODO: Should this move or copy?
				bytes = std::span{bytes.data() + sizeof(T), bytes.size() - sizeof(T)};
			}

			return out;
		}
	};
}

namespace std {
	// Import mdspan and mdarray
	using namespace std::experimental;

	// // Array which is treated as a matrix where each dimension of the matrix can be accessed with nested at/[] calls
	// template<typename T, size_t... Dimensions>
	// class multi_array : public dl::array<T, (Dimensions * ...)> {
	// 	using Base = dl::array<T, (Dimensions * ...)>;

	// 	// Helpers which get the requested dimension from the pack of dimensions
	// 	constexpr static size_t getDimension(size_t dimension_index) { return npos; }
	// 	template<typename... Dims> constexpr static size_t getDimension(size_t dimension_index, size_t first, Dims... dimensions) {
	// 		if(dimension_index <= 0) return first;
	// 		return getDimension(dimension_index - 1, dimensions...);
	// 	}

	// 	template<typename... Dims> constexpr static size_t multiplyAllButFirst(size_t first, Dims... dimensions) {
	// 		return (dimensions * ...);
	// 	}

	// 	template<typename Slice, size_t extent>
	// 	class iterator: public std::iterator<std::bidirectional_iterator_tag, Slice> {
	// 		using Base = std::iterator<std::bidirectional_iterator_tag, Slice>;
	// 		T* data;
	// 	public:
	// 		constexpr iterator(const T* data) : data(const_cast<T*>(data)) {}
	// 		constexpr inline iterator& operator++() { data += extent; return *this; }
	// 		constexpr inline iterator operator++(int) { iterator out = *this; ++(*this); return out; }
	// 		constexpr inline iterator& operator--() { data -= extent; return *this; }
	// 		constexpr inline iterator operator--(int) { iterator out = *this; --(*this); return out; }
	// 		constexpr inline bool operator==(iterator other) const { return data == other.data; }
	// 		constexpr inline bool operator!=(iterator other) const { return !(*this == other); }
	// 		constexpr inline typename Base::value_type operator*() { return data; }
	// 		constexpr inline const typename Base::value_type operator*() const { return data; }
	// 	};

	// public:
	// 	constexpr static size_t npos = std::string::npos;

	// 	// Structs used to unfold the array
	// 	template<size_t PreviousExtents, size_t... SmallerDimensions>
	// 	class subspan {
	// 		friend class multi_array;
	// 		T* data;

	// 	public:
	// 		using slice = subspan<SmallerDimensions...>;
	// 		static constexpr size_t extent = getDimension(0, SmallerDimensions...);

	// 		constexpr subspan() = default;
	// 		constexpr subspan(const T* data) : data(const_cast<T*>(data)) {}

	// 		constexpr slice at(size_t index) { if(index >= extent) throw std::out_of_range("Index " + std::to_string(index) + " out of range"); return operator[](index); }
	// 		constexpr const slice at(size_t index) const { if(index >= extent) throw std::out_of_range("Index " + std::to_string(index) + " out of range"); return operator[](index); }
	// 		constexpr inline slice operator[](size_t index) { return { data + (index * multiplyAllButFirst(SmallerDimensions...))}; }
	// 		constexpr const inline slice operator[](size_t index) const { return { data + (index * multiplyAllButFirst(SmallerDimensions...))}; }

	// 		constexpr size_t size() const { return extent; }
	// 		constexpr iterator<slice, multiplyAllButFirst(SmallerDimensions...)> begin() { return data; }
	// 		constexpr iterator<slice, multiplyAllButFirst(SmallerDimensions...)> end() { return data + (SmallerDimensions * ...); }
	// 		constexpr const iterator<slice, multiplyAllButFirst(SmallerDimensions...)> cbegin() const { return data; }
	// 		constexpr const iterator<slice, multiplyAllButFirst(SmallerDimensions...)> cend() const { return data + (SmallerDimensions * ...); }
	// 		// constexpr std::reverse_iterator<iterator<slice, multiplyAllButFirst(SmallerDimensions...)>> rbegin() { return data; }
	// 		// constexpr std::reverse_iterator<iterator<slice, multiplyAllButFirst(SmallerDimensions...)>> rend() { return data + (SmallerDimensions * ...); }
	// 		// constexpr const std::reverse_iterator<iterator<slice, multiplyAllButFirst(SmallerDimensions...)>> crbegin() const { return data; }
	// 		// constexpr const std::reverse_iterator<iterator<slice, multiplyAllButFirst(SmallerDimensions...)>> crend() const { return data + (SmallerDimensions * ...); }

	// 		// Implicit conversion to a span
	// 		// Note: The memory backing the span will only exist until a new span with the same extents is created on the same thread
	// 		operator std::span<slice, extent>() {
	// 			thread_local std::array<slice, extent> backing;
	// 			for(size_t i = 0; i < extent; i++)
	// 				backing[i] = operator[](i);
	// 			return backing;
	// 		}
	// 		operator std::span<const slice, extent>() const {
	// 			thread_local std::array<slice, extent> backing;
	// 			for(size_t i = 0; i < extent; i++)
	// 				backing[i] = operator[](i);
	// 			return backing;
	// 		}

	// 	protected:
	// 		// Recursive function facilitating multiple at
	// 		template<typename... Indices> constexpr T& at(size_t first, Indices&&... indices) { return at(first).at(indices...); }
	// 		template<typename... Indices> constexpr const T& at(size_t first, Indices&&... indices) const { return at(first).at(indices...); }
	// 	};

	// 	template<size_t PreviousExtents, size_t LowestDimensions>
	// 	class subspan<PreviousExtents, LowestDimensions> {
	// 		T* data;
	// 	public:
	// 		static constexpr size_t extent = getDimension(0, LowestDimensions);

	// 		constexpr subspan() = default;
	// 		constexpr subspan(const T* data) : data(const_cast<T*>(data)) {}

	// 		constexpr T& at(size_t index) { if(index >= extent) throw std::out_of_range("Index " + std::to_string(index) + " out of range"); return operator[](index); }
	// 		constexpr const T& at(size_t index) const { if(index >= extent) throw std::out_of_range("Index " + std::to_string(index) + " out of range"); return operator[](index); }
	// 		constexpr inline T& operator[](size_t index) { return data[index]; }
	// 		constexpr const inline T& operator[](size_t index) const { return data[index]; }

	// 		constexpr size_t size() const { return extent; }
	// 		constexpr T* begin() { return data; }
	// 		constexpr T* end() { return data + extent; }
	// 		constexpr const T* cbegin() const { return data; }
	// 		constexpr const T* cend() const { return data + extent; }
	// 		// constexpr std::reverse_iterator<T*> rbegin() { return data; }
	// 		// constexpr std::reverse_iterator<T*> rend() { return data + extent; }
	// 		// constexpr const std::reverse_iterator<T*> crbegin() const { return data; }
	// 		// constexpr const std::reverse_iterator<T*> crend() const { return data + extent; }

	// 		operator std::span<T, extent>() { return { data }; }
	// 		operator std::span<const T, extent>() const { return { data }; }
	// 	};

	// 	using slice = subspan<Dimensions...>;


	// 	// Extend size to provide information about the size of the stored dimensions
	// 	using Base::size;
	// 	inline constexpr size_t size(size_t dimension_index) const { return getDimension(dimension_index, Dimensions...); }
	// 	template<bool relative = true> constexpr inline typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type begin() { return const_cast<T*>(Base::data()); }
	// 	template<bool relative = true> constexpr inline typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type end() { return const_cast<T*>(Base::data()) + size(); }
	// 	template<bool relative = true> constexpr inline const typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type cbegin() const { return const_cast<T*>(Base::data()); }
	// 	template<bool relative = true> constexpr inline const typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type cend() const { return const_cast<T*>(Base::data()) + size(); }
	// 	// template<bool relative = true> constexpr inline std::reverse_iterator<typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type> rbegin() { return const_cast<T*>(Base::data()); }
	// 	// template<bool relative = true> constexpr inline std::reverse_iterator<typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type> rend() { return const_cast<T*>(Base::data()) + size(); }
	// 	// template<bool relative = true> constexpr inline const std::reverse_iterator<typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type> crbegin() const { return const_cast<T*>(Base::data()); }
	// 	// template<bool relative = true> constexpr inline const std::reverse_iterator<typename std::conditional<relative, iterator<slice, multiplyAllButFirst(Dimensions...)>, T*>::type> crend() const { return const_cast<T*>(Base::data()) + size(); }


	// 	// Extend access operators to use the nested structure
	// 	constexpr inline slice at(size_t index) { if(index >= size(0)) throw std::out_of_range("Index " + std::to_string(index) + " out of range"); return {Base::data() + (index * multiplyAllButFirst(Dimensions...))}; }
	// 	constexpr inline const slice at(size_t index) const { if(index >= size(0)) throw std::out_of_range("Index " + std::to_string(index) + " out of range"); return {Base::data() + (index * multiplyAllButFirst(Dimensions...))}; }
	// 	constexpr inline slice operator[](size_t index) { return at(index); }
	// 	constexpr inline const slice operator[](size_t index) const { return at(index); }

	// 	// Multi-index at operator
	// 	template<typename... Indices> constexpr inline T& at(size_t first, Indices&&... indices) {
	// 		static_assert(sizeof...(Dimensions) == sizeof...(Indices) + 1, "You must pass the same number of indices as there are dimensions in the array.");
	// 		return at(first).at(indices...);
	// 	}
	// 	template<typename... Indices> constexpr inline const T& at(size_t first, Indices&&... indices) const {
	// 		static_assert(sizeof...(Dimensions) == sizeof...(Indices) + 1, "You must pass the same number of indices as there are dimensions in the array.");
	// 		return at(first).at(indices...);
	// 	}

	// 	// operator std::span<slice, getDimension(0, Dimensions...)>() { return { data }; }

	// 	// TODO: Ensure that all of the operations supported by std::array work properlyd
	// };

	// Vector which automatically resizes itself to be as large as you request it to be
	template <typename T, class Allocator = std::allocator<T>>
	class dynamic_array : public dl::vector<T, Allocator> {
		using Base = dl::vector<T, Allocator>;
	public:
		using Base::Base;

		// The at function automatically resizes the array if trying to access an element outside of its current bounds
		constexpr T& at(size_t index) {
			if(index > this->size() || this->empty())
				this->resize(index + 1);

			return Base::operator[](index);
		}
		// The const version will invoke an error if trying to acccess an element outside of the reserved array
		constexpr const T& at(size_t index) const {
			return Base::at(index);
		}

		constexpr T& operator[](size_t index) { return at(index); }
		constexpr const T& operator[](size_t index) const { return at(index); }
	};
}

#endif /* end of include guard: ___DUCKED_C_ARRAY_HPP___ */
