#ifndef ___DUCKED_C_NUMBER_HPP___
#define ___DUCKED_C_NUMBER_HPP___

#include <boost/multiprecision/cpp_bin_float.hpp>
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/safe_numerics/safe_integer.hpp>

#include <cstdint>
#include <cstddef>

namespace std {
	template<typename T>
	concept has_numeric_limits = requires() {
		std::numeric_limits<T>::is_specialized == true;
	};

	template <has_numeric_limits T>
	class numeric_limits_wrapper {
		T value;
	public:
		template<has_numeric_limits To>
		constexpr numeric_limits_wrapper(To value) : value(value) {}

		// operator T() { return value; }
		template<has_numeric_limits To> constexpr inline operator To() const { return value; }

		// Numeric Limits Wrappers
		static constexpr bool is_signed = std::numeric_limits<T>::is_signed;
		static constexpr bool is_integer = std::numeric_limits<T>::is_integer;
		static constexpr bool is_exact = std::numeric_limits<T>::is_exact;
		static constexpr bool has_infinity = std::numeric_limits<T>::has_infinity;
		static constexpr bool has_quiet_nan = std::numeric_limits<T>::has_quiet_NaN;
		static constexpr bool has_signaling_nan = std::numeric_limits<T>::has_signaling_NaN;
		static constexpr bool has_denorm = std::numeric_limits<T>::has_denorm;
		static constexpr bool has_denorm_loss = std::numeric_limits<T>::has_denorm_loss;
		static constexpr bool round_style = std::numeric_limits<T>::round_style;
		static constexpr bool is_iec559 = std::numeric_limits<T>::is_iec559;
		static constexpr bool is_bounded = std::numeric_limits<T>::is_bounded;
		static constexpr bool is_modulo = std::numeric_limits<T>::is_modulo;
		static constexpr int digits = std::numeric_limits<T>::digits;
		static constexpr int digits10 = std::numeric_limits<T>::digits10;
		static constexpr int max_digits10 = std::numeric_limits<T>::max_digits10;
		static constexpr int radix = std::numeric_limits<T>::radix;
		static constexpr int min_exponent = std::numeric_limits<T>::min_exponent;
		static constexpr int min_exponent10 = std::numeric_limits<T>::min_exponent10;
		static constexpr int max_exponent = std::numeric_limits<T>::max_exponent;
		static constexpr int max_exponent10 = std::numeric_limits<T>::max_exponent10;
		static constexpr bool traps = std::numeric_limits<T>::traps;
		static constexpr bool tinyness_before = std::numeric_limits<T>::tinyness_before;

		static constexpr T min = std::numeric_limits<T>::min();
		static constexpr T lowest = std::numeric_limits<T>::lowest();
		static constexpr T max = std::numeric_limits<T>::max();
		static constexpr T epsilon = std::numeric_limits<T>::epsilon();
		static constexpr T round_error = std::numeric_limits<T>::round_error();
		static constexpr T infinity = std::numeric_limits<T>::infinity();
		static constexpr T nan = std::numeric_limits<T>::signaling_NaN();
		static constexpr T quiet_nan = std::numeric_limits<T>::quiet_NaN();
		static constexpr T signaling_nan = std::numeric_limits<T>::signaling_NaN();
		static constexpr T denorm_min = std::numeric_limits<T>::denorm_min();

		// Operator wrappers
		template<has_numeric_limits To> inline numeric_limits_wrapper& operator+=(To other) { value += other; return *this; }
		template<has_numeric_limits To> inline numeric_limits_wrapper& operator-=(To other) { value -= other; return *this; }
		template<has_numeric_limits To> inline numeric_limits_wrapper& operator*=(To other) { value *= other; return *this; }
		template<has_numeric_limits To> inline numeric_limits_wrapper& operator/=(To other) { value /= other; return *this; }
		template<has_numeric_limits To> inline numeric_limits_wrapper& operator%=(To other) { value %= other; return *this; }

		template<has_numeric_limits To> constexpr inline numeric_limits_wrapper<std::common_type_t<T, To>> operator+(To other) const { return value + other; }
		template<has_numeric_limits To> constexpr inline numeric_limits_wrapper<std::common_type_t<T, To>> operator-(To other) const { return value - other; }
		template<has_numeric_limits To> constexpr inline numeric_limits_wrapper							   operator-()		   const { return -value; }
		template<has_numeric_limits To> constexpr inline numeric_limits_wrapper<std::common_type_t<T, To>> operator*(To other) const { return value * other; }
		template<has_numeric_limits To> constexpr inline numeric_limits_wrapper<std::common_type_t<T, To>> operator/(To other) const { return value / other; }
		template<has_numeric_limits To> constexpr inline numeric_limits_wrapper<std::common_type_t<T, To>> operator%(To other) const { return value % other; }

		template<has_numeric_limits To> constexpr inline auto operator <=>(To other) const { return value <=> other; }
	};

	template <has_numeric_limits T>
	struct numeric_limits<numeric_limits_wrapper<T>> : public numeric_limits<T> {};
}

namespace dl::builtin {
	// Rational type
	typedef boost::multiprecision::cpp_rational rational;
	// Arbitrary precision int
	typedef boost::multiprecision::cpp_int int_arbitrary;
	typedef boost::multiprecision::cpp_int iarb;
	// Integer Type Defines
	typedef int8_t i8;
	typedef int16_t i16;
	typedef int32_t i32;
	typedef int64_t i64;
	typedef boost::multiprecision::int128_t i128;
	typedef boost::multiprecision::int256_t i256;
	typedef boost::multiprecision::int512_t i512;
	typedef boost::multiprecision::int1024_t i1024;
	typedef uint8_t u8;
	typedef uint16_t u16;
	typedef uint32_t u32;
	typedef uint64_t u64;
	typedef boost::multiprecision::uint128_t u128;
	typedef boost::multiprecision::uint256_t u256;
	typedef boost::multiprecision::uint512_t u512;
	typedef boost::multiprecision::uint1024_t u1024;
	// Fast types
	typedef int_fast8_t i8f;
	typedef int_fast16_t i16f;
	typedef int_fast32_t i32f;
	typedef int_fast64_t i64f;
	typedef i128 i128f;
	typedef i256 i256f;
	typedef i512 i512f;
	typedef i1024 i1024f;
	typedef uint_fast8_t u8f;
	typedef uint_fast16_t u16f;
	typedef uint_fast32_t u32f;
	typedef uint_fast64_t u64f;
	typedef u128 u128f;
	typedef u256 u256f;
	typedef u512 u512f;
	typedef u1024 u1024f;
	// Safe types
	typedef boost::safe_numerics::safe<int> int_safe;
	typedef boost::safe_numerics::safe<int> ints;
	typedef boost::multiprecision::checked_cpp_rational rational_safe;
	typedef boost::multiprecision::checked_cpp_rational rationals;
	typedef boost::multiprecision::checked_cpp_int int_arbitrary_safe;
	typedef boost::multiprecision::checked_cpp_int iarb_safe;
	typedef boost::multiprecision::checked_cpp_int iarbs;
	typedef boost::safe_numerics::safe<int8_t> i8s;
	typedef boost::safe_numerics::safe<int16_t> i16s;
	typedef boost::safe_numerics::safe<int32_t> i32s;
	typedef boost::safe_numerics::safe<int64_t> i64s;
	typedef boost::multiprecision::checked_int128_t i128s;
	typedef boost::multiprecision::checked_int256_t i256s;
	typedef boost::multiprecision::checked_int512_t i512s;
	typedef boost::multiprecision::checked_int1024_t i1024s;
	typedef boost::safe_numerics::safe<uint> uint_safe;
	typedef boost::safe_numerics::safe<uint> uints;
	typedef boost::safe_numerics::safe<uint8_t> u8s;
	typedef boost::safe_numerics::safe<uint16_t> u16s;
	typedef boost::safe_numerics::safe<uint32_t> u32s;
	typedef boost::safe_numerics::safe<uint64_t> u64s;
	typedef boost::multiprecision::checked_uint128_t u128s;
	typedef boost::multiprecision::checked_uint256_t u256s;
	typedef boost::multiprecision::checked_uint512_t u512s;
	typedef boost::multiprecision::checked_uint1024_t u1024s;
	
	// Wrapped Integer types
	typedef std::numeric_limits_wrapper<int> intw;
	typedef std::numeric_limits_wrapper<i8> i8w;
	typedef std::numeric_limits_wrapper<i16> i16w;
	typedef std::numeric_limits_wrapper<i32> i32w;
	typedef std::numeric_limits_wrapper<i64> i64w;
	typedef std::numeric_limits_wrapper<i128> i128w;
	typedef std::numeric_limits_wrapper<i256> i256w;
	typedef std::numeric_limits_wrapper<i512> i512w;
	typedef std::numeric_limits_wrapper<i1024> i1024w;
	typedef std::numeric_limits_wrapper<uint> uintw;
	typedef std::numeric_limits_wrapper<u8> u8w;
	typedef std::numeric_limits_wrapper<u16> u16w;
	typedef std::numeric_limits_wrapper<u32> u32w;
	typedef std::numeric_limits_wrapper<u64> u64w;
	typedef std::numeric_limits_wrapper<u128> u128w;
	typedef std::numeric_limits_wrapper<u256> u256w;
	typedef std::numeric_limits_wrapper<u512> u512w;
	typedef std::numeric_limits_wrapper<u1024> u1024w;
	// Fast wrapped types
	typedef std::numeric_limits_wrapper<i8f> i8fw;
	typedef std::numeric_limits_wrapper<i16f> i16fw;
	typedef std::numeric_limits_wrapper<i32f> i32fw;
	typedef std::numeric_limits_wrapper<i64f> i64fw;
	typedef std::numeric_limits_wrapper<i128f> i128fw;
	typedef std::numeric_limits_wrapper<i256f> i256fw;
	typedef std::numeric_limits_wrapper<i512f> i512fw;
	typedef std::numeric_limits_wrapper<i1024f> i1024fw;
	typedef std::numeric_limits_wrapper<u8f> u8fw;
	typedef std::numeric_limits_wrapper<u16f> u16fw;
	typedef std::numeric_limits_wrapper<u32f> u32fw;
	typedef std::numeric_limits_wrapper<u64f> u64fw;
	typedef std::numeric_limits_wrapper<u128f> u128fw;
	typedef std::numeric_limits_wrapper<u256f> u256fw;
	typedef std::numeric_limits_wrapper<u512f> u512fw;
	typedef std::numeric_limits_wrapper<u1024f> u1024fw;
	// Safe wrapped types
	typedef std::numeric_limits_wrapper<ints> intsw;
	typedef std::numeric_limits_wrapper<i8s> i8sw;
	typedef std::numeric_limits_wrapper<i16s> i16sw;
	typedef std::numeric_limits_wrapper<i32s> i32sw;
	typedef std::numeric_limits_wrapper<i64s> i64sw;
	typedef std::numeric_limits_wrapper<i128s> i128sw;
	typedef std::numeric_limits_wrapper<i256s> i256sw;
	typedef std::numeric_limits_wrapper<i512s> i512sw;
	typedef std::numeric_limits_wrapper<i1024s> i1024sw;
	typedef std::numeric_limits_wrapper<uints> uintsw;
	typedef std::numeric_limits_wrapper<u8s> u8sw;
	typedef std::numeric_limits_wrapper<u16s> u16sw;
	typedef std::numeric_limits_wrapper<u32s> u32sw;
	typedef std::numeric_limits_wrapper<u64s> u64sw;
	typedef std::numeric_limits_wrapper<u128s> u128sw;
	typedef std::numeric_limits_wrapper<u256s> u256sw;
	typedef std::numeric_limits_wrapper<u512s> u512sw;
	typedef std::numeric_limits_wrapper<u1024s> u1024sw;
	
	// Float Type Defines
	typedef float f32;
	typedef double f64;
	typedef boost::multiprecision::cpp_bin_float_quad f128; // Note: not the same size or bitlayout as IEEE floating point quad
	typedef boost::multiprecision::cpp_bin_float_oct f256; // Note: not the same size or bitlayout as IEEE floating point oct
	// Wrapped float
	typedef std::numeric_limits_wrapper<float> floatw;
	typedef std::numeric_limits_wrapper<double> doublew;
	typedef std::numeric_limits_wrapper<f32> f32w;
	typedef std::numeric_limits_wrapper<f64> f64w;
	// typedef std::numeric_limits_wrapper<f128> f128w;
	// typedef std::numeric_limits_wrapper<f256> f256w;
}

namespace std::rational {
	using boost::multiprecision::numerator;
	using boost::multiprecision::denominator;
}

namespace dl::literals {
// TODO: Extend extended literals to support decimal, binary, and octal in addition to hex
#define DL_DEFINE_EXTENDED_LITERALS(Bits) \
	template <char... STR> \
	constexpr BOOST_JOIN(dl::builtin::i, Bits) operator"" BOOST_JOIN(_i, Bits)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(dl::builtin::u, Bits) operator"" BOOST_JOIN(_u, Bits)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::i, Bits), w) operator"" BOOST_JOIN(BOOST_JOIN(_i, Bits), w)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::u, Bits), w) operator"" BOOST_JOIN(BOOST_JOIN(_u, Bits), w)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::i, Bits), f) operator"" BOOST_JOIN(BOOST_JOIN(_i, Bits), f)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::u, Bits), f) operator"" BOOST_JOIN(BOOST_JOIN(_u, Bits), f)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::i, Bits), fw) operator"" BOOST_JOIN(BOOST_JOIN(_i, Bits), fw)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::u, Bits), fw) operator"" BOOST_JOIN(BOOST_JOIN(_u, Bits), fw)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::unchecked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::i, Bits), s) operator"" BOOST_JOIN(BOOST_JOIN(_i, Bits), s)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::signed_magnitude, boost::multiprecision::checked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::u, Bits), s) operator"" BOOST_JOIN(BOOST_JOIN(_u, Bits), s)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::checked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::i, Bits), sw) operator"" BOOST_JOIN(BOOST_JOIN(_i, Bits), sw)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::signed_magnitude, boost::multiprecision::checked, void> >::value; \
	} \
	template <char... STR> \
	constexpr BOOST_JOIN(BOOST_JOIN(dl::builtin::u, Bits), sw) operator"" BOOST_JOIN(BOOST_JOIN(_u, Bits), sw)() { \
		using pt = typename boost::multiprecision::literals::detail::make_packed_value_from_str<STR...>::type; \
		return boost::multiprecision::literals::detail::make_backend_from_pack< \
			pt, \
			boost::multiprecision::backends::cpp_int_backend<Bits, Bits, boost::multiprecision::unsigned_magnitude, boost::multiprecision::checked, void> >::value; \
	}	


	// Numeric literals
	constexpr dl::builtin::i8     operator"" _i8    (unsigned long long x) { return x; }
	constexpr dl::builtin::i16    operator"" _i16   (unsigned long long x) { return x; }
	constexpr dl::builtin::i32    operator"" _i32   (unsigned long long x) { return x; }
	constexpr dl::builtin::i64    operator"" _i64   (unsigned long long x) { return x; }
	constexpr dl::builtin::u8     operator"" _u8    (unsigned long long x) { return x; }
	constexpr dl::builtin::u16    operator"" _u16   (unsigned long long x) { return x; }
	constexpr dl::builtin::u32    operator"" _u32   (unsigned long long x) { return x; }
	constexpr dl::builtin::u64    operator"" _u64   (unsigned long long x) { return x; }
	constexpr dl::builtin::i8f    operator"" _i8f   (unsigned long long x) { return x; }
	constexpr dl::builtin::i16f   operator"" _i16f  (unsigned long long x) { return x; }
	constexpr dl::builtin::i32f   operator"" _i32f  (unsigned long long x) { return x; }
	constexpr dl::builtin::i64f   operator"" _i64f  (unsigned long long x) { return x; }
	constexpr dl::builtin::u8f    operator"" _u8f   (unsigned long long x) { return x; }
	constexpr dl::builtin::u16f   operator"" _u16f  (unsigned long long x) { return x; }
	constexpr dl::builtin::u32f   operator"" _u32f  (unsigned long long x) { return x; }
	constexpr dl::builtin::u64f   operator"" _u64f  (unsigned long long x) { return x; }
	constexpr dl::builtin::i8s    operator"" _i8s   (unsigned long long x) { return x; }
	constexpr dl::builtin::i16s   operator"" _i16s  (unsigned long long x) { return x; }
	constexpr dl::builtin::i32s   operator"" _i32s  (unsigned long long x) { return x; }
	constexpr dl::builtin::i64s   operator"" _i64s  (unsigned long long x) { return x; }
	constexpr dl::builtin::u8s    operator"" _u8s   (unsigned long long x) { return x; }
	constexpr dl::builtin::u16s   operator"" _u16s  (unsigned long long x) { return x; }
	constexpr dl::builtin::u32s   operator"" _u32s  (unsigned long long x) { return x; }
	constexpr dl::builtin::u64s   operator"" _u64s  (unsigned long long x) { return x; }
	// Wrapped
	constexpr dl::builtin::i8w     operator"" _i8w    (unsigned long long x) { return x; }
	constexpr dl::builtin::i16w    operator"" _i16w   (unsigned long long x) { return x; }
	constexpr dl::builtin::i32w    operator"" _i32w   (unsigned long long x) { return x; }
	constexpr dl::builtin::i64w    operator"" _i64w   (unsigned long long x) { return x; }
	constexpr dl::builtin::u8w     operator"" _u8w    (unsigned long long x) { return x; }
	constexpr dl::builtin::u16w    operator"" _u16w   (unsigned long long x) { return x; }
	constexpr dl::builtin::u32w    operator"" _u32w   (unsigned long long x) { return x; }
	constexpr dl::builtin::u64w    operator"" _u64w   (unsigned long long x) { return x; }
	constexpr dl::builtin::i8fw    operator"" _i8fw   (unsigned long long x) { return x; }
	constexpr dl::builtin::i16fw   operator"" _i16fw  (unsigned long long x) { return x; }
	constexpr dl::builtin::i32fw   operator"" _i32fw  (unsigned long long x) { return x; }
	constexpr dl::builtin::i64fw   operator"" _i64fw  (unsigned long long x) { return x; }
	constexpr dl::builtin::u8fw    operator"" _u8fw   (unsigned long long x) { return x; }
	constexpr dl::builtin::u16fw   operator"" _u16fw  (unsigned long long x) { return x; }
	constexpr dl::builtin::u32fw   operator"" _u32fw  (unsigned long long x) { return x; }
	constexpr dl::builtin::u64fw   operator"" _u64fw  (unsigned long long x) { return x; }
	constexpr dl::builtin::i8sw    operator"" _i8sw   (unsigned long long x) { return x; }
	constexpr dl::builtin::i16sw   operator"" _i16sw  (unsigned long long x) { return x; }
	constexpr dl::builtin::i32sw   operator"" _i32sw  (unsigned long long x) { return x; }
	constexpr dl::builtin::i64sw   operator"" _i64sw  (unsigned long long x) { return x; }
	constexpr dl::builtin::u8sw    operator"" _u8sw   (unsigned long long x) { return x; }
	constexpr dl::builtin::u16sw   operator"" _u16sw  (unsigned long long x) { return x; }
	constexpr dl::builtin::u32sw   operator"" _u32sw  (unsigned long long x) { return x; }
	constexpr dl::builtin::u64sw   operator"" _u64sw  (unsigned long long x) { return x; }
	inline dl::builtin::rational operator""r (unsigned long long x) { return x; } // TODO: not working
	// Define literals for larger extended literal types
	DL_DEFINE_EXTENDED_LITERALS(128)
	DL_DEFINE_EXTENDED_LITERALS(256)
	DL_DEFINE_EXTENDED_LITERALS(512)
	DL_DEFINE_EXTENDED_LITERALS(1024)

	// Float literals
	constexpr dl::builtin::f32 operator"" _f32 (long double x) { return x; }
	constexpr dl::builtin::f64 operator"" _f64 (long double x) { return x; }
	inline dl::builtin::f128 operator"" _f128(long double x) { return x; }
	inline dl::builtin::f256 operator"" _f256(long double x) { return x; }
	// Wrapped
	constexpr dl::builtin::f32w operator"" _f32w (long double x) { return x; }
	constexpr dl::builtin::f64w operator"" _f64w (long double x) { return x; }
	// dl::builtin::f128w operator"" _f128w(long double x) { return x; }
	// dl::builtin::f256w operator"" _f256w(long double x) { return x; }
}

#endif // ___DUCKED_C_NUMBER_HPP___